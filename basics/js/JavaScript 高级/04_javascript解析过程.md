# JavaScript 解析过程

::: danger
本篇知识全是干货，概念居多，理解也需要花费很长的经历，也很痛苦。可以分成多个时间段来阅读。
:::

## 篇前疑问

- 说说静态作用域？什么事动态作用域呢？
- 说说你对作用域的理解呢？其规则呢？
- 你知道执行上下文吗？有哪几种分类吗？
- 你知道 AO、VO、GO 吗？它们与词法环境和变量环境有什么联系吗？
- 函数调用栈你知道吗？其中的数据结构是怎么样的呢？
- 针对不同类型的变量，在内存中是如何存储的呢？
- 能说说 JavaScript 的整体执行流程吗？是如何被 JS 引擎解析的呢？
- var 定义的变量，有变量提升，let const 定义的变量就没有，对吗？简单的来说，let const 定义变量之前使用，变量是没有被创建吗？

## 前言

JavaScript 是一种解释性语言，JavaScript 的执行分为两个阶段：`编译阶段`和`执行阶段`。

## 解析阶段

### 解析的具体步骤

其具体过程，分为三个小阶段：

- `词法解析`：将 JavaScript 代码中的字符流转换为单词流，即将源代码字符串划分为一个个 token，并为每个 token 分配一个类型，例如标识符、关键字、操作符等。词法分析器会忽略空格、注释和换行符等无意义的字符。
- `语法解析`：将词法分析器生成的 token 序列转换为抽象语法树（Abstract Syntax Tree，AST）。语法分析器会根据语法规则对 token 序列进行语义分析并生成 AST，以表示程序的结构和意图。如果源代码中存在语法错误，语法分析器会抛出错误并终止解析过程。
- `代码生成`：将 AST 转换为可执行的指令序列，也就是编译阶段的最后一步。代码生成器会对 AST 进行遍历，并生成机器可以执行的指令序列，同时进行优化以提高代码执行效率。
  `
  ::: warning 注意
  这三步，并不是上一步执行完成之后，才开始下一步的。而是相互交替执行的，连续不断地。
  :::

### 作用域的创建

在编译阶段，JavaScript 引擎会扫描代码，识别变量和函数的声明，并在内存中创建相应的作用域。更具体来说是在解析过程中的语法分析阶段。

在语法分析阶段，JavaScript 引擎会对代码进行逐行解析，并生成抽象语法树（AST）。在这个过程中，JavaScript 引擎会遇到变量和函数的声明，并进行作用域的创建。

::: tip 许久困惑
以前的想法，就是 JavaScript 已经转化为了机器码，是怎么创建的作用域的，在执行阶段有效吗？

现在的想法，就是在语法分析阶段，发现变量和函数，就创建作用域并保存在内存之后。然后在执行过程中，从内存中读取作用域里面的信息。（执行阶段，利用编译阶段创建的作用域信息进行识别）
:::

### 静态作用域

静态作用域又称为词法作用域。指在编译阶段就确定了的作用域规则，与函数的调用位置无关。

在 JavaScript 中，静态作用域是通过词法环境来实现的。词法环境记录了变量和函数的定义信息以及它们的作用域关系。每个函数在定义时都会创建一个新的词法环境对象，用于保存函数内部的变量和函数声明，并建立与外部作用域的关联。

当需要访问一个变量或函数时，JavaScript 引擎会首先搜索当前作用域的词法环境，如果找到则使用该标识符的值。如果没有找到，则会沿着词法环境的外部环境链向上查找，直到全局环境。

```js
let message = "global";
function foo() {
  console.log(message); // 打印什么？简单的静态作用域的体现
}
function bar() {
  let message = "bar";
  foo();
}
bar();
```

### 额外知识补充

编译阶段创建的`词法环境对象`，与执行阶段时，执行上下文创建的`词法环境`有什么关系？

编译阶段创建的词法环境对象和执行阶段创建的词法环境是紧密相关的。

`在编译阶段，JavaScript 引擎会为每个函数创建一个词法环境对象`，并将其与函数关联起来。这个词法环境对象中包含了函数内部的变量和函数声明，并与外部作用域建立了引用关系。

然后，在函数实际执行时，JavaScript 引擎会创建一个新的执行上下文，并在其中动态地创建一个词法环境。这个`执行上下文中的词法环境会继承自函数的编译阶段创建的词法环境对象`。

换句话说，执行阶段创建的词法环境是基于编译阶段创建的词法环境对象进行扩展的。它们之间存在着关联关系，执行阶段的词法环境可以访问和操作编译阶段定义的变量和函数声明。

## 执行阶段

JavaScript 经过编译阶段之后，就会进入执行阶段。

在执行阶段，主要也分为三个阶段：

1. 创建执行上下文
2. 执行阶段
3. 垃圾回收阶段

### 执行上下文

`执行上下文`就是 JavaScript 代码执行的环境的抽象概念。该环境中，保存着变量，函数，作用域等信息。

每当 JavaScript 引擎执行一段代码时，都会创建一个执行上下文。例如，当调用一个函数、执行一个全局代码块或者在代码中遇到 eval 语句时，都会创建一个新的执行上下文。

执行上下文又分为三种：

- `全局执行上下文`：（会发现，JavaScript 的代码不是函数，就是全局变量，而针对这些全局变量进行收集，放到一个全局执行上下文中，在调用栈中进行执行）
- `函数执行上下文`
- `eval 执行上下文`： （有一种特殊语句，eval 语句，就会单独创建一个上下文）

而针对`执行上下文的生命周期`也会分为三个部分：

- 创建阶段
  - 绑定 this
  - 创建词法环境
  - 创建变量环境
- 执行阶段
- 回收阶段

### 执行上下文栈

又被称为调用栈，它是一种拥有 LIFO（后进先出）数据结构的栈，被用来**存储代码运行时创建的所有执行上下文**。

每当函数执行时，就会创建一个执行上下文，放入栈中。当函数执行完成之后，又会从栈弹出。

### 词法环境

`词法环境（lexical environment）`是 JavaScript 中用于管理标识符（变量、函数名等）绑定和解析的数据结构。它可以理解为一个存储标识符与对应值的映射关系的容器。（这里的标识符指的是变量/函数的名字，而变量是对实际对象包含函数类型对象或原始数据的引用）

词法环境也有两种类型：一种是全局环境，一种是函数环境

词法环境由两部分组件组成：

1. 环境记录：存储标识符的实际位置
   - 对于函数环境（function environment），环境记录包含了函数的形参、函数声明和变量声明。
   - 对于全局环境（global environment），环境记录包括了全局对象（如 window）、全局变量和全局函数。
2. 外部环境引用
   - 对于全局环境，outer 为 null
   - 对于函数环境，outer 为 globalObject 或者父级词法环境

### 变量环境

是一种特殊的词法环境。

之所以在 ES5 的规范里要单独分出一个变量环境的概念是为 ES6 服务的： 在 ES6 中，词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。

看示例：

::: code-group

```js [js 源码]
let a = 20;
const b = 30;
var c;
function multiply(e, f) {
  var g = 20;
  return e * f * g;
}
c = multiply(20, 30);
```

```js [环境中的代码]
GlobalExectionContext = {
  ThisBinding: <Global Object>,
  LexicalEnvironment: {       // 词法环境
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      a: < uninitialized >,   // let、const声明的变量
      b: < uninitialized >,   // let、const声明的变量
      multiply: < func >      // 函数声明
    }
    outer: <null>
  },
  VariableEnvironment: {     // 变量环境
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      c: undefined,         // var声明的变量
    }
    outer: <null>
  }
}

FunctionExectionContext = {
  ThisBinding: <Global Object>,
  LexicalEnvironment: {         // 词法环境
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      Arguments: {0: 20, 1: 30, length: 2},   // arguments对象
    },
    outer: <GlobalLexicalEnvironment>
  },
  VariableEnvironment: {        // 变量环境
     EnvironmentRecord: {
       Type: "Declarative",
       // 在这里绑定标识符
       g: undefined            // var声明的变量
     },
     outer: <GlobalLexicalEnvironment>
  }
}


```

:::

当上面初始化好之后，就是执行代码，代码执行完成之后，就是清除垃圾。这就是 JavaScript 解析与运行 的大致过程。
