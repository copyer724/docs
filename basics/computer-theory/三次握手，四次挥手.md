# 三次握手，四次挥手

该过程发生在 tcp 建立连接，在传输层中。

<img src="/images/basics/computer-theory/34_01.png" />

## 为什么需要三次握手，四次挥手？

- 三次握手：主要是为了 让客户端和服务端都知道对方具有接受和发送数据的能力。
- 四次挥手：主要是让对方都知道，进入关闭的状态了。

## 专业术语

- SYN 同步位。 SYN = 1 ：表示建立一个连接请求。
- ACK 确认位（大写） ACK = 1 确认有效； ACK = 0 确认无效。
- ack 确认号（小写） ack = 对方发送的序号 + 1。
- FIN 关闭位 FIN = 1 说明请求关闭。

## 三次握手

<img src="/images/basics/computer-theory/34_02.png" />

- 第一次：客服端主动发送，
  - SYN = 1 表示创建了一个连接请求
  - seq = x: 随机生成了一个序号 x， 传送给服务端（表明了客服端发送数据能力）。
  - 表明了客服端有发送数据的能力
- 第二次：服务端接受到了客服端的请求，以及序号后；
  - ACK = 1 表明接受的消息有效
  - 那么服务端也会建立一个连接： SYN = 1
  - 也会随机生成一个序号 y，seq = y （表明了服务端发送数据能力）
  - 并且一同把接受客服端发送过来的序列号 x+ 1，ack = x + 1（表明了服务端接受数据能力）
  - 这几步下来，表示服务端有接受和发送数据的能力
- 第三步：服务端检查客户端是否有接受能力
  - ACK = 1 表明接受的消息有效
  - ack = y + 1: 服务端的序号 + 1 （表明了客户端接受数据能力）
  - seq = x + 1: 第一次的序号上 + 1
  - 表明了客户端也有接受数据的能力。

::: warning 注意

在前面的两次握手中，是不能发送数据的。

原因：

- 第一次握手，客户端没有确定服务端有接受数据能力，所以不会发。
- 第二次握手，服务端接受到了客户端的序号，在此基础上加 + 1，但是服务端不知道客户端是否也有接受数据能力，所以也不会发送数据。
- 在第三次中，客服端已经完全有能力知道了 服务端有接受数据和发送数据能力，所以可以发送数据了。

简单理解：只要确定一方的功能齐全后就可以发送数据了。
:::

## 四次挥手

<img src="/images/basics/computer-theory/34_03.png" />

- 当客服端没有其他的请求时，就会自动申请，主动断开。
  - FIN = 1: 表示要连接断开
  - seq = u: 这里的序号不是随机生成的，而是传送数据的最后一个字节。
- 当服务端接受到客户端的申请后，便会同意，但是由于数据还没有传送完成，等会在通知你断开。
  - ACK= 1 : 确认有效，收到了你的通知。
  - ack = u + 1: 在收到的序号 + 1；
  - seq = v: 随机生成一个序号。
- 当服务端数据传递完成后，就是正式通知客服端连接断开。
  - FIN = 1: 连接断开。
  - seq = w: 由于中途发送了数据，所以又重新生成了一个序号。
  - ACK= 1 : 确认有效，收到了你的通知。
  - ack = u + 1: 在收到的序号 + 1，客服端没有发送，继续采用上次的。
- 当客户端接受的服务端真正断开的连接的消息，就会通知，OK。
  - seq = u + 1: 没有重新发送数据，所以在原来的基础上 + 1，即可。
  - ACK= 1 : 确认有效，收到了你的通知。
  - ack = w + 1: 在收到的序号 + 1，确认收到。

::: warning
四次挥手完成之后，客服端不会立即断开，为什么呢？

客服端最后一次发送了消息，如果服务端在该时间段里没有收到消息，又会立马发送请求确认，需要客服端确认。

如果服务端在该时间内接受到了消息，就会立即断开；那么客服端超过了这段时间后，服务端没有收到消息，也就知道了服务端已经断开了，那么也就跟着断开了。
:::
